package gov.usgs.traveltime;

import java.util.ArrayList;
import java.util.logging.Logger;

/**
 * The TravelTime class contains the complete information (including auxiliary information) for all
 * phases that are generated by a source at the desired depth and source receiver-distance.
 *
 * @author Ray Buland
 */
public class TravelTime {
  /** A double containing the source depth in kilometers */
  private double depth;

  /** A double containing the source-receiver distance in degrees */
  private double distance;

  /** An ArrayList of TravelTimeData objects containing for each phase */
  private ArrayList<TravelTimeData> phaseTravelTimes;

  /** Private logging object. */
  private static final Logger LOGGER = Logger.getLogger(TravelTime.class.getName());

  /**
   * The constructor for the TravelTime class. This constructor allocates an ArrayList to hold the
   * phase data, and saves the depth and source-receiver distance for convenience.
   *
   * @param depth A double containing the source depth in kilometers
   * @param distance A double containing the source-receiver distance in degrees
   */
  public TravelTime(double depth, double distance) {
    this.depth = depth;
    this.distance = distance;

    phaseTravelTimes = new ArrayList<TravelTimeData>();
  }

  /**
   * This function adds basic travel time information for a single phase to the phase data.
   *
   * @param phaseCode A string containing the phase code
   * @param uniqueCode A unique phase code for branches with duplicate names (i.e. two versions for
   *     PKPab/PKPbc)
   * @param travelTime A double containing the travel time for this phase
   * @param distanceDerivative A double containing the derivative of time with respect to distance
   * @param depthDerivative A double containing the derivative of time with respect to depth
   * @param rayDerivative A double containing the derivative of distance with respect to the ray
   *     parameter
   * @param usePhaseStatistics A boolean flag, true if the travel-time itself needs to be modified
   *     by the phase statistical bias parameter
   */
  public void addPhase(
      String phaseCode,
      String[] uniqueCode,
      double travelTime,
      double distanceDerivative,
      double depthDerivative,
      double rayDerivative,
      boolean usePhaseStatistics) {
    phaseTravelTimes.add(
        new TravelTimeData(
            phaseCode,
            uniqueCode,
            travelTime,
            distanceDerivative,
            depthDerivative,
            rayDerivative,
            usePhaseStatistics));
  }

  /**
   * This function sets the phase statistical parameters for the most recently added (last) phase in
   * the phase data.
   *
   * @param spread A double containing the statistical spread
   * @param observability A double containing the relative statistical observability
   * @param dSdD Derivative of spread with respect to distance
   */
  public void addStatistics(double spread, double observability, double dSdD) {
    phaseTravelTimes.get(phaseTravelTimes.size() - 1).addStats(spread, observability, dSdD);
  }

  /**
   * This function sets the phase flags for the most recently added (last) phase in the phase data.
   *
   * @param phaseGroup A String containing the base phase group
   * @param auxGroup A String containing the auxiliary phase group
   * @param isRegionalPhase A boolean flag, set to true if this is a regional phase
   * @param isDepth A boolean flag, set to true if this is a depth phase
   * @param canUse A boolean flag, set to true if this phase can be used in an earthquake location
   * @param shouldDownWeight A boolean flag, set to true if this phase should be down weighted
   *     during phase identification
   */
  public void addPhaseFlags(
      String phaseGroup,
      String auxGroup,
      boolean isRegionalPhase,
      boolean isDepth,
      boolean canUse,
      boolean shouldDownWeight) {
    phaseTravelTimes
        .get(phaseTravelTimes.size() - 1)
        .addFlags(phaseGroup, auxGroup, isRegionalPhase, isDepth, canUse, shouldDownWeight);
  }

  /**
   * This function finalize the suite of travel times by sorting and filtering them (after all have
   * been added).
   *
   * @param convertTectonic A boolean flag, if true convert Pb and Sb into Pg and Sg
   * @param returnBackBranches A boolean flag, if false eliminate all back branches
   */
  public void finalizeTravelTimes(boolean convertTectonic, boolean returnBackBranches) {
    // Sort the arrival times into increasing order.
    phaseTravelTimes.sort(new ArrivalTimeCompare());

    // Filter the phases to make them easier to use.
    if (convertTectonic) {
      TauUtilities.filterTect(phaseTravelTimes);
    }

    if (!returnBackBranches) {
      TauUtilities.filterBack(phaseTravelTimes);
    } else {
      TauUtilities.filterDef(phaseTravelTimes);
    }

    // A catch all filter to compensate for strange model artifacts.
    TauUtilities.filterMisc(phaseTravelTimes, distance);

    // Modify the observabilities of phases closely following
    // another phase in time.
    TauUtilities.modObserv(phaseTravelTimes);

    // Modify canUse for phases with no statistics.
    TauUtilities.modCanUse(phaseTravelTimes);
  }

  /**
   * This function returns the number of phases in the list (found).
   *
   * @return An int containing the number of phases in the list.
   */
  public int getNumPhases() {
    return phaseTravelTimes.size();
  }

  /**
   * This function returns the trave time data for a phase by a given index.
   *
   * @param index An int containing the index of the desired phase
   * @return TravelTimeData object containing the Travel-time data
   */
  public TravelTimeData getPhase(int index) {
    return phaseTravelTimes.get(index);
  }

  /**
   * This function removes an unwanted phase by a given index.
   *
   * @param index Phase index
   */
  public void removePhase(int index) {
    phaseTravelTimes.remove(index);
  }

  /** This function logs the travel-time data for all phases as a table. */
  public void dumpPhases() {
    String phaseString = String.format("Depth = %5.1f  Delta = %6.2f", depth, distance);
    phaseString +=
        "\n    phaseCode   TravelTime    distDrv    dpthDrv   spread  observ  phGrp  auxGrp canUse isReg  isDpth dis";
    if (phaseTravelTimes.size() > 0) {
      for (int j = 0; j < phaseTravelTimes.size(); j++) {
        phaseString += String.format("\n%2d  %s", j, phaseTravelTimes.get(j));
      }
    } else {
      phaseString += String.format("\nNo arrival times found.");
    }

    LOGGER.fine(phaseString);
  }
}
