package gov.usgs.traveltime;

import java.util.ArrayList;

/**
 * This class contains complete information (including auxiliary information) for all phases
 * generated by a source at the desired depth and source receiver-distance.
 *
 * @author Ray Buland
 */
public class TTime {
  double depth; // Source depth in kilometers
  double delta; // Source-receiver distance in degrees
  ArrayList<TTimeData> tTimes;

  /**
   * The constructor just creates an ArrayList to hold the phase data. The depth and source-receiver
   * distance are remembered for convenience.
   *
   * @param depth Source depth in kilometers
   * @param delta Source-receiver distance in degrees
   */
  public TTime(double depth, double delta) {
    this.depth = depth;
    this.delta = delta;
    tTimes = new ArrayList<TTimeData>();
  }

  /**
   * Add basic travel time information for one phase.
   *
   * @param phCode Phase code
   * @param uniqueCode A unique phase code for branches with duplicate names (two versions for
   *     PKPab/PKPbc)
   * @param tt Travel time
   * @param dTdD Derivative of time with respect to distance
   * @param dTdZ Derivative of time with respect to depth
   * @param dXdP Derivative of distance with respect to ray
   * @param corrTt True if the travel-time itself needs to be modified by the statistical bias
   *     parameter
   */
  public void addPhase(
      String phCode,
      String[] uniqueCode,
      double tt,
      double dTdD,
      double dTdZ,
      double dXdP,
      boolean corrTt) {
    tTimes.add(new TTimeData(phCode, uniqueCode, tt, dTdD, dTdZ, dXdP, corrTt));
  }

  /**
   * Add phase statistical parameters.
   *
   * @param spread Statistical spread
   * @param observ Relative statistical observability
   */
  public void addStats(double spread, double observ) {
    tTimes.get(tTimes.size() - 1).addStats(spread, observ);
  }

  /**
   * Add phase flags.
   *
   * @param phGroup Base phase group
   * @param auxGroup Auxiliary phase group
   * @param isRegional True if this is a regional phase
   * @param isDepth True if this is a depth phase
   * @param canUse True if this phase can be used in an earthquake location
   * @param dis True if this phase should be down weighted during phase identification
   */
  public void addFlags(
      String phGroup,
      String auxGroup,
      boolean isRegional,
      boolean isDepth,
      boolean canUse,
      boolean dis) {
    tTimes.get(tTimes.size() - 1).addFlags(phGroup, auxGroup, isRegional, isDepth, canUse, dis);
  }

  /**
   * Finalize the suite of travel times by sorting and filtering them.
   *
   * @param tectonic If true convert Pb and Sb into Pg and Sg
   * @param returnBackBranches If false eliminate all back branches
   */
  public void finish(boolean tectonic, boolean returnBackBranches) {
    // Sort the arrival times into increasing order.
    tTimes.sort(new ArrComp());
    // Filter the phases to make them easier to use.
    if (tectonic) TauUtil.filterTect(tTimes);
    if (!returnBackBranches) TauUtil.filterBack(tTimes);
    else TauUtil.filterDef(tTimes);
    // A catch all filter to compensate for strange model artifacts.
    TauUtil.filterMisc(tTimes, delta);
    // Modify the observabilities of phases closely following
    // another phase in time.
    TauUtil.modObserv(tTimes);
    // Modify canUse for phases with no statistics.
    TauUtil.modCanUse(tTimes);
  }

  /**
   * Provide a way of getting the number of phases found.
   *
   * @return The number of phases in the list.
   */
  public int size() {
    return tTimes.size();
  }

  /**
   * Provide a way of getting the data for each phase by index.
   *
   * @param i Phase index
   * @return Travel-time structure
   */
  public TTimeData get(int i) {
    return tTimes.get(i);
  }

  /**
   * Provide a way of removing an unwanted phase by index.
   *
   * @param i Phase index
   */
  public void remove(int i) {
    tTimes.remove(i);
  }

  /** Print the travel-time data for all phases as a table. */
  public void print() {
    System.out.println();
    System.out.format("Depth = %5.1f  Delta = %6.2f\n", depth, delta);
    if (tTimes.size() > 0) {
      for (int j = 0; j < tTimes.size(); j++) {
        System.out.format("%2d  %s", j, tTimes.get(j));
      }
    } else {
      System.out.println("No arrival times found.");
    }
  }
}
