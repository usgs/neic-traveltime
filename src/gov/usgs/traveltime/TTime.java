package gov.usgs.traveltime;

import java.util.ArrayList;

/**
 * This class contains complete information (including auxiliary 
 * information) for all phases generated by a source at the desired 
 * depth and source receiver-distance.
 * 
 * @author Ray Buland
 *
 */
public class TTime {
	double depth;				// Source depth in kilometers
	double delta;				// Source-receiver distance in degrees
	ArrayList<TTimeData> tTimes;
	
	/**
	 * The constructor just creates an ArrayList to hold the phase 
	 * data.  The depth and source-receiver distance are remembered for 
	 * convenience.
	 * 
	 * @param depth Source depth in kilometers
	 * @param delta Source-receiver distance in degrees
	 */
	public TTime(double depth, double delta) {
		this.depth = depth;
		this.delta = delta;
		tTimes = new ArrayList<TTimeData>();
	}
	
	/**
	 * Add basic travel time information for one phase.
	 * 
	 * @param phCode Phase code
	 * @param tt Travel time
	 * @param dTdD Derivative of time with respect to distance
	 * @param dTdZ Derivative of time with respect to depth
	 * @param dXdP Derivative of distance with respect to ray
	 * @param corrTt True if the travel-time itself needs to be modified 
	 * by the statistical bias
	 * parameter
	 */
	public void addPhase(String phCode, String[] uniqueCode, double tt, 
			double dTdD,double dTdZ, double dXdP, boolean corrTt) {
		tTimes.add(new TTimeData(phCode, uniqueCode, tt, dTdD, dTdZ, dXdP, 
				corrTt));
	}
	
	/**
	 * Add phase statistical parameters.
	 * 
	 * @param spread Statistical spread
	 * @param observ Relative statistical observability
	 */
	public void addStats(double spread, double observ) {
		tTimes.get(tTimes.size()-1).addStats(spread, observ);
	}
	
	/**
	 * Add phase flags.
	 * 
	 * @param phGroup Base phase group
	 * @param auxGroup Auxiliary phase group
	 * @param isRegional True if this is a regional phase
	 * @param isDepth True if this is a depth phase
	 * @param canUse True if this phase can be used in an 
	 * earthquake location
	 * @param dis True if this phase should be down weighted 
	 * during phase identification
	 */
	public void addFlags(String phGroup, String auxGroup, 
			boolean isRegional, boolean isDepth, boolean canUse, 
			boolean dis) {
		tTimes.get(tTimes.size()-1).addFlags(phGroup, auxGroup, 
				isRegional, isDepth, canUse, dis);
	}
	
	/**
	 * Finalize the suite of travel times by sorting and 
	 * filtering them.
	 * 
	 * @param tectonic If true convert Pb and Sb into Pg and Sg
	 * @param noBackBrn If true eliminate all back branches
	 */
	public void finish(boolean tectonic, boolean noBackBrn) {
		//Sort the arrival times into increasing order.
		tTimes.sort(new ArrComp());
		// Filter the phases to make them easier to use.
		if(tectonic) TauUtil.filterTect(tTimes);
		if(noBackBrn) TauUtil.filterBack(tTimes);
		else TauUtil.filterDef(tTimes);
		// A catch all filter to compensate for strange model artifacts.
		TauUtil.filterMisc(tTimes, delta);
		// Modify the observabilities of phases closely following 
		// another phase in time.
		TauUtil.modObserv(tTimes);
		// Modify canUse for phases with no statistics.
		TauUtil.modCanUse(tTimes);
	}
	
	/**
	 * Provide a way of getting the number of phases found.
	 * 
	 * @return The number of phases in the list.
	 */
	public int size() {
		return tTimes.size();
	}
	
	/**
	 * Provide a way of getting the data for each phase by index.
	 * 
	 * @param i Phase index
	 * @return Travel-time structure
	 */
	public TTimeData get(int i) {
		return tTimes.get(i);
	}
	
	/**
	 * Provide a way of removing an unwanted phase by index.
	 * 
	 * @param i Phase index
	 */
	public void remove(int i) {
		tTimes.remove(i);
	}
	
	/**
	 * Print the travel-time data for all phases as a table.
	 * 
	 */
	public void print() {
		System.out.println();
		System.out.format("Depth = %5.1f  Delta = %6.2f\n", depth, delta);
		if(tTimes.size() > 0) {
			for(int j=0; j<tTimes.size(); j++) {
				System.out.format("%2d  %s", j, tTimes.get(j));
			}
		} else {
			System.out.println("No arrival times found.");
		}
	}
}